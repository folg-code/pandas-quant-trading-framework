import os
from time import perf_counter
from concurrent.futures import ProcessPoolExecutor, as_completed

import pandas as pd

from config.backtest import INITIAL_BALANCE
from core.backtesting.reporting.core.contex_enricher import TradeContextEnricher
from core.backtesting.reporting.core.preparer import RiskDataPreparer
from core.backtesting.reporting.runner import ReportRunner
from core.data_provider.backend_factory import create_backtest_backend
from core.data_provider.default_provider import DefaultOhlcvDataProvider
from core.data_provider.cache import MarketDataCache

from core.backtesting.backtester import Backtester
from core.backtesting.raporter import BacktestReporter
from core.backtesting.plotting.plot import TradePlotter

from core.strategy.runner import run_strategy_single
from core.strategy.strategy_loader import load_strategy_class


class BacktestRunner:
    """
    Orchestrates:
    - data loading
    - strategy execution (possibly multi-symbol)
    - backtesting
    - reporting
    - plotting
    """

    def __init__(self, cfg):
        self.config = cfg
        self.provider = None

        # üîë STRATEGY CONTRACT
        self.strategy = None          # reference strategy (for reporting config)
        self.strategies = []          # all strategy instances (per symbol)

        self.signals_df = None
        self.trades_df = None

    # ==================================================
    # 1Ô∏è‚É£ LOAD DATA ONCE
    # ==================================================

    def load_data(self):

        t_start = perf_counter()
        print("‚è±Ô∏è load_data | start")

        backend = create_backtest_backend(self.config.BACKTEST_DATA_BACKEND)

        start = pd.Timestamp(self.config.TIMERANGE["start"], tz="UTC")
        end = pd.Timestamp(self.config.TIMERANGE["end"], tz="UTC")

        self.provider = DefaultOhlcvDataProvider(
            backend=backend,
            cache=MarketDataCache(self.config.MARKET_DATA_PATH),
            backtest_start=start,
            backtest_end=end,
        )

        all_data = {}

        for symbol in self.config.SYMBOLS:
            t_sym = perf_counter()

            df = self.provider.get_ohlcv(
                symbol=symbol,
                timeframe=self.config.TIMEFRAME,
                start=start,
                end=end,
            )

            print(
                f"‚è±Ô∏è load_data | get_ohlcv {symbol:<10} "
                f"{perf_counter() - t_sym:8.3f}s  ({len(df)} rows)"
            )

            all_data[symbol] = df

        print(f"‚è±Ô∏è load_data | TOTAL {perf_counter() - t_start:8.3f}s")
        return all_data

    # ==================================================
    # 2Ô∏è‚É£ RUN STRATEGIES (PARALLEL)
    # ==================================================

    def run_strategies_parallel(self, all_data: dict):

        t_start = perf_counter()
        print(f"üìà STRATEGIES | start ({len(all_data)} symbols)")

        all_signals = []
        self.strategies = []
        self.strategy = None

        # =================================================
        # üî• SINGLE SYMBOL
        # =================================================
        if len(all_data) == 1:
            symbol, df = next(iter(all_data.items()))

            df_signals, strategy = run_strategy_single(
                symbol,
                df,
                self.provider,
                load_strategy_class(self.config.STRATEGY_CLASS),
                self.config.STARTUP_CANDLE_COUNT,
            )

            all_signals.append(df_signals)
            self.strategies.append(strategy)
            self.strategy = strategy

        # =================================================
        # üöÄ MULTI SYMBOL
        # =================================================
        else:
            with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
                futures = [
                    executor.submit(
                        run_strategy_single,
                        symbol,
                        df,
                        self.provider,
                        load_strategy_class(self.config.STRATEGY_CLASS),
                        self.config.STARTUP_CANDLE_COUNT,
                    )
                    for symbol, df in all_data.items()
                ]

                for future in as_completed(futures):
                    df_signals, strategy = future.result()

                    all_signals.append(df_signals)
                    self.strategies.append(strategy)

                    # üîë set reference strategy ONCE
                    if self.strategy is None:
                        self.strategy = strategy

        if not all_signals:
            raise RuntimeError("No signals generated by strategies")

        self.signals_df = (
            pd.concat(all_signals)
            .sort_values(by=["time", "symbol"])
            .reset_index(drop=True)
        )

        print(f"üìà STRATEGIES | TOTAL {perf_counter() - t_start:8.3f}s")
        return self.signals_df

    # ==================================================
    # 3Ô∏è‚É£ BACKTEST WINDOWS
    # ==================================================

    def _run_backtest_window(self, start, end, label):

        df_slice = self.signals_df[
            (self.signals_df["time"] >= start) &
            (self.signals_df["time"] <= end)
        ].copy()

        if df_slice.empty:
            raise RuntimeError(f"No signals in window: {label}")

        backtester = Backtester(slippage=self.config.SLIPPAGE)
        trades = backtester.run_backtest(df_slice)
        trades["window"] = label
        return trades

    # ==================================================
    # 4Ô∏è‚É£ RUN BACKTEST(S)
    # ==================================================

    def run_backtests(self):

        if self.config.BACKTEST_MODE == "single":
            start = pd.Timestamp(self.config.TIMERANGE["start"], tz="UTC")
            end = pd.Timestamp(self.config.TIMERANGE["end"], tz="UTC")

            self.trades_df = self._run_backtest_window(start, end, "FULL")

        elif self.config.BACKTEST_MODE == "split":
            all_trades = []

            for name, (start, end) in self.config.BACKTEST_WINDOWS.items():
                trades = self._run_backtest_window(
                    pd.Timestamp(start, tz="UTC"),
                    pd.Timestamp(end, tz="UTC"),
                    name
                )
                all_trades.append(trades)

            self.trades_df = (
                pd.concat(all_trades)
                .sort_values(by=["exit_time", "symbol"])
                .reset_index(drop=True)
            )

        else:
            raise ValueError(f"Unknown BACKTEST_MODE: {self.config.BACKTEST_MODE}")

        if self.trades_df.empty:
            raise RuntimeError("No trades after backtest")

        return self.trades_df

    # ==================================================
    # 5Ô∏è‚É£ REPORTING (RISK / STRATEGY)
    # ==================================================

    def run_report(self):

        # 1Ô∏è‚É£ PREPARE RISK STATE
        preparer = RiskDataPreparer(
            initial_balance=INITIAL_BALANCE
        )
        prepared_df = preparer.prepare(self.trades_df)

        # 2Ô∏è‚É£ ENRICH CONTEXTS (CANDLE ‚Üí TRADE)
        enricher = TradeContextEnricher(self.strategy.df_plot)
        prepared_df = enricher.enrich(
            prepared_df,
            self.strategy.report_config.contexts
        )

        print(prepared_df.columns.tolist())

        print(
            prepared_df["bos_bear_struct_vol"]
            .value_counts(dropna=False)
            .head()
        )

        print(
            prepared_df["trend_regime"]
            .value_counts(dropna=False)
            .head()
        )

        # 3Ô∏è‚É£ RUN REPORT (PURE)
        ReportRunner(
            strategy=self.strategy,
            trades_df=prepared_df,
            config=self.config
        ).run()

    # ==================================================
    # 6Ô∏è‚É£ PLOTTING
    # ==================================================

    def plot_results(self):

        plots_folder = "results/plots"
        os.makedirs(plots_folder, exist_ok=True)

        for strategy in self.strategies:
            symbol = strategy.symbol

            trades_symbol = None
            if self.trades_df is not None:
                trades_symbol = self.trades_df[
                    self.trades_df["symbol"] == symbol
                ]
                if trades_symbol.empty:
                    trades_symbol = None

            plotter = TradePlotter(
                df=strategy.df_plot,
                trades=trades_symbol,
                bullish_zones=strategy.get_bullish_zones(),
                bearish_zones=strategy.get_bearish_zones(),
                extra_series=strategy.get_extra_values_to_plot(),
                bool_series=strategy.bool_series(),
                title=f"{symbol} chart",
            )

            plotter.plot()
            plotter.save(f"{plots_folder}/{symbol}.png")

    # ==================================================
    # 7Ô∏è‚É£ MAIN ENTRYPOINT
    # ==================================================

    def run(self):

        t_start = perf_counter()
        print("üöÄ BacktestRunner | start")

        # LOAD DATA
        all_data = self.load_data()

        # STRATEGIES
        self.run_strategies_parallel(all_data)

        # PLOT ONLY
        if self.config.PLOT_ONLY:
            self.plot_results()
            print(f"üìä Plot-only finished TOTAL {perf_counter() - t_start:.3f}s")
            return

        # BACKTEST
        self.run_backtests()

        if self.config.BACKTEST_MODE == "backtest":
            print(f"üß™ Backtest finished TOTAL {perf_counter() - t_start:.3f}s")
            return

        # REPORT
        self.run_report()

        print(f"üèÅ Full run finished TOTAL {perf_counter() - t_start:.3f}s")
